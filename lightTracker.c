#pragma config(Sensor, S1,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S2,     sonic,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
/*
 * Title: Line Follower
 * Author: Anjan and Wonchul
 *
 * !!Code automatically generated by 'ROBOTC' configuration wizard!!
 */

#define TURN_SPEED 27
#define BASE_SPEED 5
#define DELAY_TIME 80
#define SENSOR_VAL_ON_EDGE 111

task main()
{
	int const MIL_IN_SEC = 1000;
	int const LENGTH_OF_TICK = 10;
	int const FREQUENCY = 300;
	float const TURN_DAMPENER = 70.3569;
	// DO NOT CHANGE THE FOLLOWING:
	int soundPlayed = 0;
	int turnArm = 0;
	int countForArmBack = 0;
	float const BEEP_WHEN_OBJ_THIS_DIS = 10;
	int const DELAY_TIME_AFTER_BEEP = (700 / 160);
	int const TURNING_DEGREE = 130;

	while(true){
		float test = SensorValue[S2]; //if we use sensor value for sonic, it reads in mm

		if(SensorValue[sonic] / 10 < BEEP_WHEN_OBJ_THIS_DIS && soundPlayed == 0){
			playTone(FREQUENCY, MIL_IN_SEC / LENGTH_OF_TICK);
			soundPlayed = 1;
			turnArm = 1;
		}

	 	motor[leftMotor] = BASE_SPEED;
	 	motor[rightMotor] = BASE_SPEED;

		//displayCenteredBigTextLine(4, "%d", sense);
		//delay(1000);
		//eraseDisplay();
    delay(DELAY_TIME);
		int sense = 0;
		sense = SensorValue[S1];

		int turnLeftCalled = 0;
		int turnRightCalled = 0;

    if(sense > SENSOR_VAL_ON_EDGE) {
			turnLeftCalled++;
			turnRightCalled = 0;
			motor[leftMotor] = -(TURN_SPEED + turnLeftCalled * TURN_DAMPENER);
			motor[rightMotor] = TURN_SPEED + turnLeftCalled * TURN_DAMPENER;
			delay(DELAY_TIME);
		}
		if(sense < SENSOR_VAL_ON_EDGE){
			turnRightCalled++;
			turnLeftCalled = 0;
			motor[leftMotor] = TURN_SPEED + turnRightCalled * TURN_DAMPENER;
			motor[rightMotor] = -(TURN_SPEED + turnRightCalled * TURN_DAMPENER);
		  delay(DELAY_TIME);
		}

		if(turnArm){
			moveMotorTarget(armMotor, TURNING_DEGREE, 60);
			turnArm = 0;
		}
		if(soundPlayed){
			countForArmBack++;
		}
		if(countForArmBack == DELAY_TIME_AFTER_BEEP && soundPlayed == 1){
			moveMotorTarget(armMotor, TURNING_DEGREE, -30);
			soundPlayed = 0;
			countForArmBack = 0;
		}
	}
}
