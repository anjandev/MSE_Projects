#pragma config(Sensor, S1,     light,          sensorEV3_Color)
#pragma config(Motor,  motorA,          innerMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          outerMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float atan2d(float y, float x);
float sqd(float num2Square);

float const L1 = 9; // everything in cm
float const L2 = 13;

float const INNER_GEAR_RATIO_MULTIPLE = 40;
float const OUTER_GEAR_RATIO_MULTIPLE = 5;
  
int const FORWARD = 30;
int const FORWARD_OUTER = FORWARD / OUTER_GEAR_RATIO_MULTIPLE;

//80 mm dis

// we found that our y was not staying constant, therefore we created a parabola model that 
// increses y sufficently such that y stays constant
float yDampener(float x){
	// need an upward facing parabola to cancel arcing effect
	// arm rotating generates a downward parabola
	float const PARABOLA_COEFFICENT = 0.0439;
	float const Y_INTERCEPT = 18;
	return PARABOLA_COEFFICENT*sqd(x) + Y_INTERCEPT;
		
}

void moveToCoords (float x, float y){
	float YForTheta2_Nosqd = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float YForTheta2 = sqrt(1-sqd(YForTheta2_Nosqd));
	float XForTheta2 = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float theta2 = atan2d(YForTheta2, XForTheta2);
	
  float k1 = L2 * cosDegrees(theta2) + L1;
  float k2 = L2 * sinDegrees(theta2);
  float theta1 = atan2d(y,x) - atan2d(k2, k1);
  
  setMotorTarget(innerMotor, theta1 * INNER_GEAR_RATIO_MULTIPLE, FORWARD);
  setMotorTarget(outerMotor, theta2 * OUTER_GEAR_RATIO_MULTIPLE, FORWARD_OUTER);
  // 68
  // 94
}


task main()
{
	// move arm into intial position
	float const INITIAL_X = 14.5;
	float const INITIAL_Y = 15;

	moveToCoords (INITIAL_X, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	eraseDisplay();
	
	float const SLOPE = -(115/275)
	
	float const X_MIN = -14.5;
	float const X_DECREMENT = 1;
	int index = 0;
	
	for(float x = INITIAL_X; x > X_MIN ; x -= X_DECREMENT){
		moveToCoords (x, INITIAL_Y);
		repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
			// store data
		}
		displayCenteredTextLine(5, "%d", x);
		index = index + 1;
	}
	/*
	float const NEW_MIN_X = X_MIN * 2;
	
	for(float x = X_MIN; x > NEW_MIN_X; x -= X_DECREMENT){
		
		moveToCoords (x, INITIAL_Y);
		repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
			// store data
		}
		displayCenteredTextLine(5, "%d", x);
		index = index + 1;
	}*/
		
}

float sqd(float num2Square){
	return num2Square *	num2Square;
}

float atan2d(float y, float x){
	return radiansToDegrees(atan2(y, x));
}