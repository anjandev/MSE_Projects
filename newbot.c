#pragma config(Sensor, S1,     light,          sensorEV3_Color)
#pragma config(Motor,  motorA,          innerMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          outerMotor,    tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float atan2d(float y, float x);
float sqd(float num2Square);

float const L1 = 0.09; // everything in cm
float const L2 = 0.13;

float const INNER_GEAR_RATIO_MULTIPLE = 40;
float const OUTER_GEAR_RATIO_MULTIPLE = 5;

int const FORWARD = 60;
int const FORWARD_OUTER = FORWARD / OUTER_GEAR_RATIO_MULTIPLE;

void moveToCoords1 (float x, float y){
	float YForTheta2_Nosqd = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float YForTheta2 = sqrt(1-sqd(YForTheta2_Nosqd));
	float XForTheta2 = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float theta2 = atan2d(YForTheta2, XForTheta2);
	
  float k1 = L2 * cosDegrees(theta2) + L1;
  float k2 = L2 * sinDegrees(theta2);
  float theta1 = atan2d(y,x) - atan2d(k2, k1);
  
  setMotorTarget(innerMotor, theta1 * INNER_GEAR_RATIO_MULTIPLE, FORWARD);
  setMotorTarget(outerMotor, theta2 * OUTER_GEAR_RATIO_MULTIPLE, FORWARD_OUTER);
	displayCenteredTextLine(4, "%d", theta1);
	displayCenteredTextLine(5, "%d", theta2);
}

void moveToCoords2 (float x, float y){
	float YForTheta2_Nosqd = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float YForTheta2 = sqrt(1-sqd(YForTheta2_Nosqd));
	float XForTheta2 = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float theta2 = atan2d(YForTheta2, XForTheta2);
	
  float k1 = L2 * cosDegrees(theta2) + L1;
  float k2 = L2 * sinDegrees(theta2);
  float theta1 = atan2d(y,x) - atan2d(k2, k1);
  
  setMotorTarget(innerMotor, theta1 * INNER_GEAR_RATIO_MULTIPLE, FORWARD);
  setMotorTarget(outerMotor, theta2 * OUTER_GEAR_RATIO_MULTIPLE, -FORWARD_OUTER);
	displayCenteredTextLine(4, "%d", theta1);
	displayCenteredTextLine(5, "%d", theta2);
}


task main()
{

	// move arm into intial position
	float const INITIAL_X = 0.145;
	float const INITIAL_Y = 0.13;
	

	
	moveToCoords1(INITIAL_X, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	
	float const INITIAL_X2 = 0.1;
	moveToCoords1(INITIAL_X2, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	
	float const INITIAL_X3 = 0.06;
	moveToCoords1(INITIAL_X3, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	
	float const INITIAL_X4 = 0.00;
	moveToCoords1(INITIAL_X4, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	/*
	float const INITIAL_X5 = -0.04;
	moveToCoords1(INITIAL_X5, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}	
	/*
	float const INITIAL_X6 = -0.10;
	moveToCoords1(INITIAL_X6, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
	
	float const INITIAL_X7 = -0.16;
	moveToCoords1(INITIAL_X7, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}
/*
	
	float const X_MIN = -0.145;
	float const X_DECREMENT = 0.0003;
	int index = 0;
	
	for(float x = INITIAL_X; x > 0.05 ; x -= X_DECREMENT){
		moveToCoords1(x, INITIAL_Y);
		repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
			// store data
		}
		displayCenteredTextLine(5, "%d", x);
		index = index + 1;
	}


    
	
/*
	moveToCoords(L1+L2, 0);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}*/
}

float sqd(float num2Square){
	return num2Square *	num2Square;
}

float atan2d(float y, float x){
	return radiansToDegrees(atan2(y, x));
}