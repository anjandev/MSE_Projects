#pragma config(Sensor, S1,     distance,       sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftDrive,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightDrive,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PRESENT 1

typedef struct{
	int NWall;
	int SWall;
	int EWall;
	int WWall;
	char Visited;
}cell;

int const ONE_ROTATION = 360;
int const QUARTER_ROTATION = 180;


float const FRICTION_DAMPENER = 1.5;
float const SIZE_OF_ONE_CELL = 22.5425 + FRICTION_DAMPENER;
int const DRIVE_GEAR_RATIO = 5;
float const RADIUS_OF_WHEEL = 3.5; // cm
float const CIRCUMFERENCE_OF_WHEEL = 2 * PI * RADIUS_OF_WHEEL;

int const FORWARD = 100;
int const BACKWARD = -FORWARD;

int const MAZE_WIDTH = 4;
int const MAZE_HEIGHT = 6;
int const LAST_MAZE_HEIGHT_INDEX = MAZE_HEIGHT - 1;
int const LAST_MAZE_WIDTH_INDEX = MAZE_WIDTH - 1;
cell Maze[MAZE_HEIGHT][MAZE_WIDTH];

void goFwdCell();
void Turn90CW();
void Turn90CCW();
void UTurn();

task main(){
		
// Assigning walls [row][col]
	for (int c = 0; c < MAZE_WIDTH; c++){
		Maze[0][c].SWall = PRESENT;
		Maze[LAST_MAZE_HEIGHT_INDEX][c].NWall = PRESENT;
	}

	for (int r = 0; r < MAZE_HEIGHT; r++){
		Maze[r][0].WWall = PRESENT;
		Maze[r][LAST_MAZE_WIDTH_INDEX].EWall = PRESENT;

	}
	
	goFwdCell();
	Turn90CW();
	goFwdCell();
	Turn90CCW();
}

void goFwdCell(){
	moveMotorTarget(leftDrive, (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO * ONE_ROTATION, FORWARD);
	moveMotorTarget(rightDrive, (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO * ONE_ROTATION, FORWARD);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){
		
	}
}

void Turn90CW(){
	moveMotorTarget(leftDrive, DRIVE_GEAR_RATIO * QUARTER_ROTATION, FORWARD);
	moveMotorTarget(rightDrive, DRIVE_GEAR_RATIO * QUARTER_ROTATION, BACKWARD);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){
		
	}
}

void Turn90CCW(){
	moveMotorTarget(leftDrive, DRIVE_GEAR_RATIO * QUARTER_ROTATION, BACKWARD);
	moveMotorTarget(rightDrive, DRIVE_GEAR_RATIO * QUARTER_ROTATION, FORWARD);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){
		
	}
}

void UTurn(){
	Turn90CW();
	Turn90CW();
}