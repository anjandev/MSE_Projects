#pragma config(Sensor, S1,     distance,       sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftDrive,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightDrive,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PRESENT 1
float const DIST_BETWEEN_BOT_AND_WALL = 7.4;
// Define directions using numbers
#define NORTH 0
#define EAST 1
#define SOUTH 2
#define WEST 3

typedef struct{
	int NWall;
	int SWall;
	int EWall;
	int WWall;
	char Visited;
}cell;


// CHANGE THESE IF ANYTHING MECHANICAL. MAKE SURE YOU TEST THESE
int const SPEED_ON_MOTOR_DIF = 13;
float const UNCERTAINTY_STRAIGHT = 28;
float const UNCERTAINTY_ROT = 53;

// Movement Variabels defined
float const ONE_ROTATION = 360 + UNCERTAINTY_STRAIGHT;
int direction = 0;
float const QUARTER_ROTATION = 180 + UNCERTAINTY_ROT;


float const SIZE_OF_ONE_CELL = 22.5425; //cm
float const DRIVE_GEAR_RATIO = 5;
float const DIAMETER_OF_WHEEL = 5.5; // cm
float const CIRCUMFERENCE_OF_WHEEL = PI * DIAMETER_OF_WHEEL;

// Speed Variable
int const FORWARD = -100;
int const BACKWARD = -FORWARD;

// MAZE VARIABLES
int const MAZE_WIDTH = 4;
int const MAZE_HEIGHT = 6;
int const LAST_MAZE_HEIGHT_INDEX = MAZE_HEIGHT - 1;
int const LAST_MAZE_WIDTH_INDEX = MAZE_WIDTH - 1;
cell Maze[MAZE_HEIGHT][MAZE_WIDTH];

// Call functions
void goFwdCell();
void Turn90CW();
void Turn90CCW();
void UTurn();
void WallInFront();
void MovementWithSensor();


task main(){

// Assigning walls [row][col]
	for (int c = 0; c < MAZE_WIDTH; c++){
		Maze[0][c].SWall = PRESENT;
		Maze[LAST_MAZE_HEIGHT_INDEX][c].NWall = PRESENT;
	}

	for (int r = 0; r < MAZE_HEIGHT; r++){
		Maze[r][0].WWall = PRESENT;
		Maze[r][LAST_MAZE_WIDTH_INDEX].EWall = PRESENT;

	}
	
	/*
	goFwdCell();
	Turn90CW();
	UTurn();
	goFwdCell();
	Turn90CCW();
	
	Turn90CW();
	*/
	
	while(1){
		MovementWithSensor();
	}
	
}

void goFwdCell(){
	moveMotorTarget(leftDrive, (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO * ONE_ROTATION, FORWARD);
	moveMotorTarget(rightDrive, (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO * ONE_ROTATION, FORWARD + SPEED_ON_MOTOR_DIF);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

	}
}

void Turn90CCW(){
	moveMotorTarget(leftDrive, QUARTER_ROTATION * DRIVE_GEAR_RATIO, BACKWARD);
	moveMotorTarget(rightDrive, QUARTER_ROTATION * DRIVE_GEAR_RATIO, FORWARD);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

	}
	if(direction < 3){
		direction++;
	}
	else{
		direction = NORTH;
	}

}

void Turn90CW(){
	moveMotorTarget(leftDrive, QUARTER_ROTATION * DRIVE_GEAR_RATIO, FORWARD);
	moveMotorTarget(rightDrive, QUARTER_ROTATION * DRIVE_GEAR_RATIO, BACKWARD);
	repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

	}

	if(direction == 0){
		direction = 3;
	}
	else{
		direction--;
	}
}

void UTurn(){
	Turn90CW();
	Turn90CW();
}

int thereIsWall(){
	if(getUSDistance(distance)<=DIST_BETWEEN_BOT_AND_WALL || getUSDistance(distance)==255){
		return 1;
	}

	return 0;
}

// Checking order, North(0), East(1), West(3) then South(2)
void MovementWithSensor(){
	cell current;

	int backWall = 0;
	int enteringDirectionWall = thereIsWall();

	if(direction == NORTH && thereIsWall()){
		current.NWall = 1;
		enteringDirectionWall = 1;
	}
	else if(direction == SOUTH && thereIsWall()){
		current.SWall = 1;
		enteringDirectionWall = 1;
	}
	else if(direction == EAST && thereIsWall()){
		current.EWall = 1;
		enteringDirectionWall = 1;
	}
	else if(direction == WEST && thereIsWall()){
		current.WWall = 1;
		enteringDirectionWall = 1;
	}

	if(direction == NORTH && !thereIsWall()){
		current.NWall = 0;
	}
	else if(direction == SOUTH && !thereIsWall()){
		current.SWall = 0;
	}
	else if(direction == EAST && !thereIsWall()){
		current.EWall = 0;
	}
	else if(direction == WEST && !thereIsWall()){
		current.WWall = 0;
	}

	// turn to check if wall is right
	Turn90CW();

	if(!thereIsWall()){
		goFwdCell();
		return;
	}

	if(thereIsWall() && !enteringDirectionWall){
		Turn90CCW();
		goFwdCell();
		return;
	}

	Turn90CW();
	Turn90CW();

	if(!thereIsWall()){
		goFwdCell();
		return;
	}

	Turn90CCW();
	goFwdCell();
}