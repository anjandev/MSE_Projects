\documentclass[11pt]{article}
\usepackage[margin=0.7in]{geometry}
\newcommand{\ts}{\textsuperscript}
%Gummi|065|=)
\date{}
\usepackage{caption}
%%%%% Please Check this section %%%%%
\title{Table of Contents}

\usepackage{lineno, blindtext}
\usepackage{color}
\usepackage{graphicx}
\begin{document}

\maketitle

\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%															%%
%% 							Section 1    					%%
%% 															%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Progress Report}
\subsection{1\ts{st} Iteration}
Should be achieved by: July 12, 2016
\begin{itemize}
\item Robot moves forward exactly one cell length and turns 90 $^{\circ}$ accurately\\
This is the most important feature of our robot. By ensuring accurate movement, we limit the need to readjust in each cell.
\item Robot follows right wall\\
This is the algorithm needed to find the unique solution to the maze. Once movement is implemented, we can just build on top of it to collect more data as we move through the maze. 
\end{itemize}

\subsection{2\ts{nd} Iteration}
Should be achieved by: July 12, 2016
\begin{itemize}
\item Robot tracks its orientation and location in maze\\
This is dependency for most of the other requirements. By tracking movement in the cell, we are able to know when we have reached our goal, how we reached it (in order to implement coming back shortest path) and where to store cell information in our 2-D array.
\item Robot beeps when reached target
\item Robot stores wall information, visited/unvisited status and orientation at entry in 2-D array.\\
This is required for more advanced algorithm features we wish to implement such as having the robot not check the same wall twice. Furthermore, this was required in order to display current location and wall information graphically. We chose to implement it now because it was a major criteria requirement. 
\end{itemize}

\subsection{3\ts{rd} Iteration}
Should be achieved by: July 19, 2016
\begin{itemize}
\item Robot returns with shortest path\\
Since we know the route we took to get to our final location, we can now implement the cancelling algorithm (described in detail in \textbf{Section 3.16}).
\item Robot displays current location graphically on screen\\
We implemented this now so that we could more easily test our algorithm. The last project feature we wanted to implement was to not check the same wall twice. We thought that this would be difficult to implement and as such improved our debugging capabilities before continuing.
\end{itemize}

\subsection{4\ts{th} Iteration}
Should be achieved by: July 26, 2016
\begin{itemize}
\item Improve algorithm such that robot doesn't check same wall twice\\
The premise behind this optimization is that imagine that we are in a cell with a wall to the South. If we've checked that there is a wall toward the South, we know that in the cell below our current cell, there is a wall to the North. The most general case will be programmed and described in \textbf{Section 3}. This has two major advantages: we do not have to waste time turning and we do not incur extra error because of unneeded turning.
\end{itemize}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%															%%
%% 							Section 2    					%%
%% 															%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Mechanical Design of MazeBot}
\subsection{Top Level Mechanical Structure and Specifications}
Our robot needed very accurate movement in order to be successful in the maze. This criteria depends heavily on whether or not the motor encoders report accurate values to the algorithm. In order to achieve this, we had to ensure:

\begin{itemize}
\item The wheels do not slip
\item The robot does not hit walls
\item The drive system is sturdy 
\item The gears are securely held in place and make proper contact. 
\end{itemize}
However, there is a limit to how much we can to do minimize mechanical error in movement. As a result, we will have to readjust after a certain number of cells. This is done by driving into the wall, turning 90$^{\circ}$ and driving into the wall again. However, having to readjust too often is problematic as this adds time to our average time in each cell which is a major criteria point. As a result, we hope to minimize the amount of times we needed to readjust by maximizing the accuracy of the mechanical system. 
\newpage

\subsection{First Iteration}

\begin{itemize}
\item \textbf{Goals:}
	\begin{itemize}
	\item Able to go 3 cells without needing to readjust
	\item Able to turn 90$^{\circ}$ accurately.
	\end{itemize}
\end{itemize}
\begin{figure}[htp]
\centering
\captionsetup{justification=centering}
\minipage{0.32\textwidth}
\includegraphics[scale=0.80]{images/Hardware_Mechanical/First_Iteration_Design_Driving_System.png}
\caption{First Iteration Drive System}\label{fig:Drive System}
\endminipage\hfill
\minipage{0.32\textwidth}
\includegraphics[scale=0.70]{images/Hardware_Mechanical/First_Iteration_Design_FrontView.png}
\caption{First Iteration Front View}\label{fig:Front View}
\endminipage\hfill
\minipage{0.32\textwidth}
\includegraphics[scale=0.70]{images/Hardware_Mechanical/First_Iteration_Design_SideView.png}
\caption{First Iteration Side View}\label{Side View}
\endminipage
\end{figure}
\begin{figure}[!tbp]
  \centering
  \begin{minipage}[b]{0.33\textwidth}
\includegraphics[scale=0.18]{images/Hardware_Mechanical/First_Iteration_Front.jpg}
\caption{First Iteration Front View}\label{fig:Front View}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.4\textwidth}
\includegraphics[scale=0.18]{images/Hardware_Mechanical/First_Iteration_Left.jpg}
\caption{First Iteration Side View}\label{Side View}
  \end{minipage}
\end{figure}
\newpage
\begin{itemize}
\item \textbf{Observations \& Measurements}
	\begin{itemize}
	\item \textbf{Goal}: Able to go 3 cells without needing to readjust
	\item \textbf{Failed}: Needed to readjust every second cell
	\item \textbf{Goal}: Able to turn 90$^{\circ}$ accurately.\\
	Test - An error of even $ \pm 1^{\circ}$ will cause accumulate to a significant error when traversing cells. However, error in turning is hard to notice. Therefore, we chose to have robot turn 90$^{\circ}$ 8 times in place in order to propogate any error significantly.
	\item \textbf{Failed}: Robot had error of $ \pm 20^{\circ}$
	\end{itemize}
\item \textbf{Reasons for Test Failures}
	\begin{itemize}
	\item \textbf{Structural Integrity of the Drive System}\\
	We are unable to find space to properly secure the left and right drive wheels. When testing, we found one wheel to slipped forward and the other to slipped back when turning which defeats the accuracy of the encoder. Because of this, we are unable to meet our goal of accurate movement.
	\item \textbf{Robot is too large.}\\
	Since the brick is upright, it is top heavy. We needed two rods in the back and one metal ball in the front in order to balance the robot. The additions of the two rods and one metal ball negates the spacial advantage of having the robot's brick be upright. Even though the dimensions of the robot are within the size of one square, it leaves very little room for error. As such, the robot begins to run into walls after the 2\ts{nd} turn.
	\item \textbf{Wheels are too big}\\
	In order for the motor encoder to be accurate, the wheels must not slip. In order to maximize friction, we decided to use the largest wheels in the set. However. the extra friction with the ground from the larger wheels is not worth the extra size added to the robot. When we replaced the large wheels with smaller wheels, we noticed little to no change in accuracy of movement.
	\end{itemize}
\item \textbf{Conclusion}\\
In conclusion, we have decided to no longer have our robot upright. This will allow us to have enough room to properly secure the drive system. Which will allow us to ensure that the gears make proper contact and do slide forward or backward. This ensures maximum encoder accuracy. By having the robot level with the table, we will be able to take out the additional support that we needed before to hold the bot upright. This will allow more room for error when turning and going into new cells.
\end{itemize}
\newpage

\subsection{Second Iteration}
\begin{itemize}
\item \textbf{Goals:}
	\begin{itemize}
	\item Able to go 3 cells without needing to readjust
	\item Able to turn 90$^{\circ}$ accurately.
	\end{itemize}
\end{itemize}
\begin{figure}[htp]
\centering
\captionsetup{justification=centering}
\minipage{0.32\textwidth}
\includegraphics[scale=0.80]{images/Hardware_Mechanical/Third_Iteration_Design_drive.png}
\caption{Second Iteration Drive System}\label{fig:Drive System}
\endminipage\hfill
\minipage{0.32\textwidth}
\includegraphics[scale=0.70]{images/Hardware_Mechanical/Third_Iteration_Design_front.png}
\caption{Second Iteration Front View}\label{fig:Front View}
\endminipage\hfill
\minipage{0.32\textwidth}
\includegraphics[scale=0.70]{images/Hardware_Mechanical/Third_Iteration_Design_side.png}
\caption{Second Iteration Side View}\label{Side View}
\endminipage
\end{figure}
\begin{figure}[htp]
\centering
\captionsetup{justification=centering}
\minipage{0.24\textwidth}
\includegraphics[scale=0.13]{images/Hardware_Mechanical/Third_Iteration_3D.jpg}
\caption{Second Iteration Drive System}\label{fig:Drive System}
\endminipage\hfill
\minipage{0.32\textwidth}
\includegraphics[scale=0.17]{images/Hardware_Mechanical/Third_Iteration_Front.jpg}
\caption{Second Iteration Front View}\label{fig:Front View}
\endminipage\hfill
\minipage{0.27\textwidth}
\includegraphics[scale=0.17]{images/Hardware_Mechanical/Third_Iteration_Left.jpg}
\caption{Second Iteration Side View}\label{Side View}
\endminipage
\end{figure}
\newpage
\begin{itemize}
\item \textbf{Observations \& Measurements}
	\begin{itemize}
	\item \textbf{Goal}: Able to go 3 cells without needing to readjust
 	\item \textbf{Passed}: Needed to readjust every fifth cell
 	\item \textbf{Goal}: Able to turn 90$^{\circ}$ accurately.\\
	Test - An error of even $ \pm 1^{\circ}$ will cause accumulate to a significant error when traversing cells. However, error in turning is hard to notice. Therefore, we chose to have robot turn 90$^{\circ}$ 8 times in place in order to propogate any error significantly. 
	\item \textbf{Passed}: Robot had an unnoticeable error even after eight turns
	\end{itemize}
\item \textbf{Reasons for Test Successes}\\
Our hypotheses were correct. By securing the gears, we were able to make the motor encoders much more accurate and as a result, have the robot move in much more controlled way. Furthermore, having the robot much more compact allowed the system to have a larger tolerance for error.
\item \textbf{Conclusion}\\
After much contemplation, we have decided that this is the best design. The need to readjust cannot be avoided because of the uncertainty in turning caused by the legos flexing and backlash in the gears. In order to further reduce the error, we have decided to make the algorithm for the robot as efficient as possible. An example of this is to avoid turning to check for walls as much as possible because turning is our least accurate movement.
\end{itemize}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%															%%
%% 							Section 3    					%%
%% 															%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Software Design of MazeBot}
The main goal with the software of the mazebot was to create program that solved the problem simply and was easy to build upon. Furthermore, we wanted our software to have very few constants that we would need to tested for. For example, in order to move forward one cell, we would need to give the following function the degrees to move each of our drive motors:
\begin{verbatim}
		setMotorSyncEncoder(leftDrive, rightDrive, 0, Degrees, BACKWARD);
\end{verbatim}
The degrees needed to move one cell forward could be achieved by constantly testing different values of degrees to achieve the movement to the new cell. However, we chose to calculate the exact degrees that the robot's drive motors would need to move in order to move exactly one cell forward. This approach in contrast to the former has two advantages: 
\begin{enumerate}
\item It allows us to isolate any problems with moving accurately to a mechanical problem.
\item We would not have an accumulation of error because of us testing incorrectly.
\end{enumerate}
Therefore, we chose to mathematically calculate the degrees that we needed to move the motors rather than testing.\\\\
A sketch of the derivation of how many degrees to move forward is shown below: %ADD SKETCH HERE% 
\\
Therefore:
\begin{verbatim}
degrees = (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL) * DRIVE_GEAR_RATIO * ONE_ROTATION
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%															%%
%% 					Do not remove the gap 					%%
%% 		From this, these are explanations of the code		%%
%%															%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

%% 3.1 - Position of the robot and size of the maze

\subsection{Variables Used to Define the Position of the Robot in the Maze and the Size of the Maze}
\begin{itemize}
\item Two constant that represent the initial position of the robot in the maze were declared. These will be entered when we begin our demo.
	\begin{verbatim}
		int const START_ROW = ;
		int const START_COL = ;
	\end{verbatim} 
\item Two constants that represent the target position in the maze were declared. These will be entered when we begin our demo.
	\begin{verbatim}
		int const END_ROW = ; 
		int const END_COL = ;
	\end{verbatim}
\item Two global variables that represent the current position of the robot in the maze were declared. These are  initialized as the starting position. 
	\begin{verbatim}
		int currentRow = START_ROW;
		int currentCol = START_COL;
	\end{verbatim} 
\item An array that represents the orientation that the bot has as it enters each cell was defined. The size of the array is four times larger than the product of the maze width and maze height because the maximum amount of times that the robot can go into each cell is four times (worst case scenario).
	\begin{verbatim}
		int entered[MAZE_WIDTH*MAZE_HEIGHT*4];
		int lastEnteredIdx = 0;
	\end{verbatim} 
\item A constant that represents the dimension of a single cell was defined
	\begin{verbatim}
		float const SIZE_OF_ONE_CELL = 22.5425; // in cm 	
	\end{verbatim} 
\item Four constants that represent the size of the maze were declared
	\begin{verbatim}
		int const MAZE_WIDTH = 4;
		int const MAZE_HEIGHT = 6;
		int const LAST_MAZE_HEIGHT_INDEX = MAZE_HEIGHT - 1;
		int const LAST_MAZE_WIDTH_INDEX = MAZE_WIDTH - 1;
	\end{verbatim} 
\end{itemize}
\newpage

%% 3.2

\subsection{Constants and Variables Used for Representation of Directions}
\begin{itemize}
\item The four constants that represent each of the directions were declared:
	\begin{verbatim}
		#define NORTH 0
		#define EAST 1
		#define SOUTH 2
		#define WEST 3
	\end{verbatim}
\item A structure named cell was declared and it has five parameters. This track where the walls are, what direction we entered from and whether we have visited the cell.
	\begin{verbatim}
		typedef struct{
   int NWall; 
   int SWall; 
   int EWall; 
   int WWall; 
   char Visited;
   int entryDir;
}cell;\end{verbatim}
\item A 2-D array called "Maze" with the data type cell was declared. This data type is described above.
	\begin{verbatim}
		cell Maze[MAZE_HEIGHT][MAZE_WIDTH];
	\end{verbatim}
\end{itemize}

%% 3.3

\subsection{Constants Used for Display}
\begin{itemize}
\item Two constants that represent the size of the screen width and height were defined
	\begin{verbatim}
		#define SCREEN_HEIGHT 127
		#define SCREEN_WIDTH 177 
	\end{verbatim} 
\item Two constants that represent the each cell's size on the screen were defined
	\begin{verbatim}
		#define CELL_HEIGHT (SCREEN_HEIGHT / MAZE_HEIGHT)
		#define CELL_WIDTH (SCREEN_WIDTH / MAZE_WIDTH)
	\end{verbatim} 
\item Two constants are defined which represent the robot's position in each cell in the screen
	\begin{verbatim}
		#define CELL_HEIGHT_MIDDLE (CELL_HEIGHT / 2)
		#define CELL_WIDTH_MIDDLE (CELL_WIDTH /2)
	\end{verbatim}
\end{itemize}
\newpage

%% 3.4

\subsection{Constants Used for Moving Mechanism}
\begin{itemize}
\item When we calculated the degrees to move the encoder, we had two contributing errors that caused the motors to move less than they needed to. First of all, we were using integer division to find the degrees to move the motors. Therefore, the remainder is truncated and this causes the robot to move less than one cell or less than 90$^{\circ}$. Similarly, the PID control caused the robot to move less than the desired target. Therefore, three constants were declared which are added to the encoder input values and only needed to be tested once in order to supplement the errors. 
	\begin{verbatim}
		float const UNCERTAINTY_STRAIGHT = 23;
		float const UNCERTAINTY_ROT = 28;
		float const UNCERTAINTY_READJUST = 35;
	\end{verbatim} 
\item Back and forward speed of the motors were defined with constants for simplification of the code. 
	\begin{verbatim}
		int const FORWARD = -100;
		int const BACKWARD = -FORWARD;
	\end{verbatim} 
\item Encoder input constants were declared
	\begin{verbatim}
		float const ONE_ROTATION = 360 + UNCERTAINTY_STRAIGHT;
		float const QUARTER_ROTATION = 180 + UNCERTAINTY_ROT;
		float const DRIVE_GEAR_RATIO = 5;
		float const DIAMETER_OF_WHEEL = 5.5; // in cm
		float const CIRCUMFERENCE_OF_WHEEL = PI * DIAMETER_OF_WHEEL;
	\end{verbatim} 
\item The amount of time that the bot will drive into the wall in order to readjust was defined. Timing algorithm was used because the flat surface at the front of the robot adjusts the bot as it drives into the wall.
	\begin{verbatim}
		int const MILISECS_TO_DRIVE_INTO_WALL = 1100;
	\end{verbatim} 
\item A constant that represents how often the robot has to readjust its direction was defined. A global variable that increases every time the robot goes into new cells to count for readjust was also defined.
	\begin{verbatim}
		int const CELLS_TO_READJUST_AFTER = 3;
		int timesForwardWithoutReadjust = 0;
	\end{verbatim}  
\end{itemize}
\newpage

%% 3.5

\subsection{Constants Used for Representation of Wall}
\begin{itemize}
\item A constant which represent the maximum distance possible between the robot and an object for the robot to consider it a wall.
	\begin{verbatim}
		float const DIST_BETWEEN_BOT_AND_WALL = 7.6;
	\end{verbatim}
\item Three constants were defined that represent the robot's knowledge of whether or not there is a wall. 
	\begin{verbatim}
		#define NOT_PRESENT 0 
		#define PRESENT 1
		#define UNKNOWN 2
	\end{verbatim}
\end{itemize}

%% 3.6

\subsection{Constants Used for Beeping Mechanism}
\begin{itemize}
\item A constant which represent the time and the frequency of the beep when the robot found the target
	\begin{verbatim}
		int const MILI_TO_BEEP_FOR = 200;
		int const FREQUENCY = 300;
	\end{verbatim}
\end{itemize}

\newpage

%% 3.7

\subsection{Displaying Function}
\begin{itemize}
\item Function for displaying information about the robot's orientation and location on the screen as well as what it knows about the maze. 
	\begin{verbatim}
		void drawInfo(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.57]{images/Software_Flowchart/Drawing_Function.png}
\caption{Flow Chart for Displaying Function}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function but it does not return any variable
	\item Global variables and constants used are
	\begin{verbatim}
		MAZE_WIDTH     MAZE_HEIGHT
		CELL_WIDTH     CELL_HEIGHT
		CELL_WIDTH_MIDDLE     CELL_HEIGHT_MIDDLE
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
	PRESENT
	currentCol     currentRow
	NORTH     SOUTH     EAST     WEST
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.8

\subsection{Moving Forward Function}
\begin{itemize}
\item This function moves the the robot forward exactly one cell. It also stores the cell information in the maze array. Finally, it increments how many cells it has moved without readjust. 
	\begin{verbatim}
		void goFwdCell(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.52]{images/Software_Flowchart/Moving_Forward.png}
\caption{Flow Chart for Moving Forward}
\label{}
\end{figure}	
	\begin{itemize}
	\item The local variable direction is passed into the function but it does not return any variable
	\item Global variables and constants used are
	\begin{verbatim}
		SIZE_OF_ONE_CELL     CIRCUMFERENCE_OF_WHEEL
		DRIVE_GEAR_RATIO     ONE_ROTATION     FORWARD
		NORTH     SOUTH     EAST     WEST
		currentCol     currentRow
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
		timesForwardWithoutReadjust
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.9

\subsection{Turning Functions}
\begin{itemize}
\item Function for turning right.
\begin{verbatim}
	int Turn90CW(int direction);
\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/Software_Flowchart/Turning_Right.png}
\caption{Flow Chart for Turning Right}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function. The function returns the new direction.
	\item Global constants used are
	\begin{verbatim}
		QUARTER_ROTATION     DRIVE_GEAR_RATION
		FORWARD
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		int findRight(int direction);
		int drawInfo(int direction);
	\end{verbatim}
	\end{itemize}
\item Function for turning left 
\begin{verbatim}
	Turn90CW(int direction);
\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.60]{images/Software_Flowchart/Turning_Left.png}
\caption{Flow Chart for Turning Left}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function. The function returns the new direction.
	\item Global constants used are
	\begin{verbatim}
		QUARTER_ROTATION     DRIVE_GEAR_RATION
		FORWARD
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		int findLeft(int direction);
		int drawInfo(int direction);
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.10

\subsection{Wall Detecting Function}
\begin{itemize}
\item Function that returns whether or not there is a wall in front of the bot.
	\begin{verbatim}
		int thereIsWall();
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.60]{images/Software_Flowchart/Detecting_Wall.png}
\caption{Flow Chart for Wall Detecting Function}
\label{}
\end{figure}
	\begin{itemize}
	\item Very simple fuction that returns $1$ if the sensor detects the wall
	\item Global constant used is
	\begin{verbatim}
		DIST_BETWEEN_BOT_AND_WALL
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.11

\subsection{Function for Storing Data of the Walls}
\begin{itemize}
\item Function that writes whether there is a wall in the direction the robot is currently facing into the maze array.
	\begin{verbatim}
		void writeWall(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{images/Software_Flowchart/writeWall.png}
\caption{Flow Chart for Storing Data Function}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function but it does not return any variable.
	\item Global variables and constants used are:
	\begin{verbatim}
		NORTH     SOUTH     EAST     WEST
		currentCol     currentRow
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
		PRESENT
		LAST_MAZE_HEIGHT_INDEX     LAST_MAZE_WIDTH_INDEX
	\end{verbatim}
	\item Function used is
	\begin{verbatim}
		int thereIsWall();
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.12

\subsection{Functions for setting up the direction that need to be used}
\begin{itemize}
\item Function that takes in a direction of the robot and returns the direction towards the back.
	\begin{verbatim}
		int findBackDir(int currentDirection);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.45]{images/Software_Flowchart/findBackDir.png}
\caption{Flow Chart for Finding Back Function}
\label{}
\end{figure}
\item Function that takes in a direction of the robot and returns the direction to the right of the robot.
	\begin{verbatim}
		int findRight(int currentDirection);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.47]{images/Software_Flowchart/findRight.png}
\caption{Flow Chart for Finding Right Function}
\label{}
\end{figure}	
\item Function that takes in a direction of the robot and returns the direction to the left of the robot.
	\begin{verbatim}
		int findLeft(int currentDirection);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.48]{images/Software_Flowchart/findLeft.png}
\caption{Flow Chart for Finding Left Function}
\label{}
\end{figure}
	\begin{itemize}
	\item Global constants used are
	\begin{verbatim}
		NORTH     SOUTH     EAST     WEST
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.13

\subsection{Functions for Finding Existence of Wall from the data}
\begin{itemize}
\item Function takes in a direction and returns whether or not there is a wall in that direction from maze array.
	\begin{verbatim}
		int isThereWallInDir(int wallDir);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.580]{images/Software_Flowchart/isThereWallInDir.png}
\caption{Flow Chart for Finding Existence of Wall from the data}
\label{}
\end{figure}
	\begin{itemize}
	\item Global variables and constants used are
	\begin{verbatim}
		NORTH     SOUTH     EAST     WEST
		PRESENT     UNKNOWN     NOT_PRESENT
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.14

\subsection{Functions for Readjusting in Certain Directions}
\begin{itemize}
\item Function that readjusts robot's position by driving into the wall and coming back to the center of the cell. For this function particularly, we readjust using walls to the front and to the right.
	\begin{verbatim}
		void reAdjustCW(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.52]{images/Software_Flowchart/reAdjustCW.png}
\caption{Flow Chart for Readjusting using Front wall and Right wall}
\label{}
\end{figure}
\item Function that readjusts robot's position by driving into the wall and coming back to the center of the cell. For this function particularly, we readjust using walls to the back and to the left.
	\begin{verbatim}
		void reAdjustCCW(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.52]{images/Software_Flowchart/reAdjustCCW.png}
\caption{Flow Chart for Readjusting using Back wall and Left wall}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function but it does not return any variable
	\item Global variables and constants used are
	\begin{verbatim}
		SIZE_OF_ONE_CELL     CIRCUMFERENCE_OF_WHEEL
		DRIVE_GEAR_RATIO     ONE_ROTATION     UNCERTAINTY_READJUST
		FORWARD     BACKWARD     MILLISECS_TO_DRIVE_INTO_WALL
		NORTH     SOUTH     EAST     WEST
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
		timesForwardWithoutReadjust
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		int Turn90CW(int direction);
		int Turn90CCW(int direction);
	\end{verbatim}
	\end{itemize}
\item Function that decides which direction to readjust in using the data collected in array. Once the function decides the direction to readjust in, it calls that function.
	\begin{verbatim}
		void reAdjustWayBack(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.46]{images/Software_Flowchart/reAdjustWayBack.png}
\caption{Flow Chart for Readjusting using walls detected}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function but it does not return any variable
	\item Global variable and constants used are
	\begin{verbatim}
		timesForwardWithoutReadjust
		CELLS_TO_READJUST_AFTER
		PRESENT
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		thereIsWall();
		reAdjustCW(int direction);
		reAdjustCCW(int direction);
		findLeft(int currentDirection);
		findRight(int currentDirection);
		findBackDir(int currentDirection);
		isThereWallInDir(int wallDir);
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.15

\subsection{Function for Movement All Together}
\begin{itemize}
\item Function that implements the right following algorithm using the functions described above. Furthermore, it ensures that the robot readjusts whenever it can.
	\begin{verbatim}
		int MovementWithSensor(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.45]{images/Software_Flowchart/MovementWithSensor.png}
\caption{Flow Chart for Movement Function}
\label{}
\end{figure}
	\begin{itemize}
	\item The local variable direction is passed into the function and it returns a new variable direction.
	\item Global constants used are
	\begin{verbatim}
		NOT_PRESENT     UNKNOWN
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		writewall(int direction);
		reAdjustWayBack(int direction);
		isThereWallInDir(int wallDir);
		findRight(int currentDirection);
		thereIsWall();
		goFwdCell(int direction);
		Turn90CCW(int direction);
		Turn90CW(int direction);
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.16

\subsection{Functions for Returning Algorithm}
\begin{itemize}
\item Function that deletes the duplicates from the array which saved up how the robot entered each cell. For example, if the robot moved two opposite directions in order, it is not necessary. Therefore, we delete the duplicates from the array
 	\begin{verbatim}
		void deleteDuplicates();
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.50]{images/Software_Flowchart/deleteDuplicate.png}
\caption{Flow Chart for Deleting Duplicate Function}
\label{}
\end{figure}
	\begin{itemize}
	\item Global variables used:
 		\begin{verbatim}
			entered[]     lastEnteredIdx
		\end{verbatim}
	\end{itemize}
\item Function that reverses the direction from the array which saved up how the robot entered each cell. For example, if the robot went into the cell with direction East, then we change it to West. Therefore, we change all the directions to its opposite.
 	\begin{verbatim}
		void reverseDirection();
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.50]{images/Software_Flowchart/reverseDirection.png}
\caption{Flow Chart for Reversing Order of Values in the Array}
\label{}
\end{figure}
	\begin{itemize}
	\item Global variables and constants used:
 		\begin{verbatim}
			entered[]     lastEnteredIdx
			NORTH     SOUTH     EAST     WEST
		\end{verbatim}
	\end{itemize}
\item Function that takes in the variable direction and goes back to the initial position in the cell with the new array created by two functions above
 	\begin{verbatim}
		void goingBackFastestRoute(int direction);
	\end{verbatim}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.53]{images/Software_Flowchart/goingBackFastestRoute.png}
\caption{Flow Chart for Function to Go Back to Initial Position}
\label{}
\end{figure}
	\begin{itemize}
	\item Global variables and constants used are
	\begin{verbatim}
		entered[]     lastEnteredIdx
		NORTH     SOUTH     EAST     WEST
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		reAdjustWayBack(int direction);	
		Turn90CW(int direction);
		Turn90CCW(int direction);
		goFwdCell(int direction);
	\end{verbatim}
	\end{itemize}
\end{itemize}
\newpage

%% 3.17

\subsection{Main Function}
\begin{itemize}
\item More than ten functions were declared for simplicity of the main function. This function sums up all smaller functions
	\begin{verbatim}
		task main()
	\end{verbatim}

	\begin{itemize}
	\item A variable that represents current direction of the robot was declared. This is initialized as north as this is the orientation of the robot when it first enters the maze.
	\begin{verbatim}
		int direction = NORTH;
	\end{verbatim}
	\item Global variables and constants used are
	\begin{verbatim}
		MAZE_WIDTH     MAZE_HEIGHT
		entered[]     lastEnteredIdx
		FREQUENCY     MILI_TO_BEEP_FOR
		Maze[][].NWall     Maze[][].SWall     Maze[][].EWall     Maze[][].WWall
		Maze[][].entryDir     Maze[][].Visited
		PRESENT     UNKNOWN
		LAST_MAZE_HEIGHT_INDEX     LAST_MAZE_WIDTH_INDEX 
		currentCol     currentRow    				
	\end{verbatim}
	\item Functions used are
	\begin{verbatim}
		MovmentWithSensor(int direction);
		deleteDuplicates();
		reverseDirection();
		goingBackFastestRoute(int direction);
		drawInfo(int direction);
	\end{verbatim}
	\end{itemize}
\item Flow chart is on the next page
\end{itemize}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/Software_Flowchart/task_main.png}
\caption{Flow Chart of the Main Function}
\label{}
\end{figure}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%															%%
%% 							Section 4    					%%
%% 															%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Appendix}
\subsection{Full Source Code}

\begin{linenumbers}
\begin{verbatim}
    #pragma config(Sensor, S1, distance, sensorEV3_Ultrasonic)
    #pragma config(Motor, motorA, leftDrive, tmotorEV3_Large, PIDControl, driveLeft, encoder)
    #pragma config(Motor, motorD, rightDrive, tmotorEV3_Large, PIDControl, driveRight, encoder)
    //*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

    // Constants for robot's knowledge
    #define NOT_PRESENT 0
    #define PRESENT 1
    #define UNKNOWN 2

    // Maximum distance between robot and the wall
    float const DIST_BETWEEN_BOT_AND_WALL = 7.6;

    // Define directions using numbers
    #define NORTH 0
    #define EAST 1
    #define SOUTH 2
    #define WEST 3

    typedef struct{
        int NWall;
        int SWall;
        int EWall;
        int WWall;
        int Visited;
        int entryDir;
    }cell;

    // Starting and End positions defined with Row and Column numbers
    // These positions were used for the Demo
    int const START_ROW = 2;
    int const START_COL = 0;
    int const END_ROW = 3;
    int const END_COL = 4;
    // (3,0) to (3,4) - longest route was the longest path for the practice

    // Current position defined
    int currentRow = START_ROW;
    int currentCol = START_COL;

    // Constants for beeping mechanism
    int const MILI_TO_BEEP_FOR = 200;
    int const FREQUENCY = 300;

    // Uncertainty due to property of integer division of computer
    float const UNCERTAINTY_STRAIGHT = 19;
    float const UNCERTAINTY_ROT = 27;
    float const UNCERTAINTY_READJUST = 35;

    // Movement Variabels defined
    float const ONE_ROTATION = 360 + UNCERTAINTY_STRAIGHT;
    float const QUARTER_ROTATION = 180 + UNCERTAINTY_ROT;
    float const SIZE_OF_ONE_CELL = 22.5425; //cm
    float const DRIVE_GEAR_RATIO = 5;
    float const DIAMETER_OF_WHEEL = 5.5; // cm
    float const CIRCUMFERENCE_OF_WHEEL = PI * DIAMETER_OF_WHEEL;

    // Speed Variable
    int const FORWARD = -100;
    int const BACKWARD = -FORWARD;

    // MAZE VARIABLES
    int const MAZE_WIDTH = 6;
    int const MAZE_HEIGHT = 4;
    int const LAST_MAZE_HEIGHT_INDEX = MAZE_HEIGHT - 1;
    int const LAST_MAZE_WIDTH_INDEX = MAZE_WIDTH - 1;
    cell Maze[MAZE_HEIGHT][MAZE_WIDTH];

    // Array to save up how the robot entered each cells
    int entered[MAZE_WIDTH*MAZE_HEIGHT*4];
    int lastEnteredIdx = 0;

    // Constants for displaying mechanism
    #define SCREEN_HEIGHT 127
    #define	SCREEN_WIDTH 177
    #define CELL_HEIGHT	(SCREEN_HEIGHT / MAZE_HEIGHT)
    #define CELL_WIDTH (SCREEN_HEIGHT / MAZE_WIDTH)
    #define CELL_HEIGHT_MIDDLE (CELL_HEIGHT / 2)
    #define CELL_WIDTH_MIDDLE (CELL_WIDTH / 2)

    // Constants for readjusting mechanism
    int const MILLISECS_TO_DRIVE_INTO_WALL = 1100;
    int const CELLS_TO_READJUST_AFTER = 3;
    int timesForwardWithoutReadjust = 0;

    // Call functions
    void goFwdCell(int direction);
    int Turn90CW(int direction);
    int Turn90CCW(int direction);
    int MovementWithSensor(int direction);
    void reverseDirection();
    void deleteDuplicates();
    int goingBackFastestRoute(int direction);
    void drawInfo(int direction);
    void reAdjustCCW(int direction);
    void reAdjustCW(int direction);
    int findLeft(int currentDirection);
    int findRight(int currentDirection);
    int findBackDir (int currentDirection);
    int isThereWallInDir(int wallDir);
    void reAdjustWayBack(int direction);


    void drawInfo(int direction){
        eraseDisplay();

        for(int r = 0; r < MAZE_HEIGHT; r++){
            for(int c = 0; c < MAZE_WIDTH; c++){

                if(Maze[r][c].SWall == PRESENT){
                    drawLine(c*CELL_WIDTH,r*CELL_HEIGHT,c*CELL_WIDTH + CELL_WIDTH,r*CELL_HEIGHT);
                }
                if(Maze[r][c].NWall == PRESENT){
                    drawLine(c*CELL_WIDTH,r*CELL_HEIGHT + CELL_HEIGHT,
                             c*CELL_WIDTH + CELL_WIDTH,r*CELL_HEIGHT + CELL_HEIGHT);
                }
                if(Maze[r][c].WWall == PRESENT){
                    drawLine(c*CELL_WIDTH,r*CELL_HEIGHT,c*CELL_WIDTH,
                             r*CELL_HEIGHT + CELL_HEIGHT);
                }
                if(Maze[r][c].EWall == PRESENT){
                    drawLine(c*CELL_WIDTH + CELL_WIDTH,r*CELL_HEIGHT,
                             c*CELL_WIDTH + CELL_WIDTH, r*CELL_HEIGHT + CELL_HEIGHT);
                }
            }
        }

        if(direction == NORTH){
            displayBigStringAt(currentCol*CELL_WIDTH + CELL_WIDTH_MIDDLE, 
                               currentRow*CELL_HEIGHT + CELL_HEIGHT_MIDDLE, "^");
        }
        else if(direction == EAST){
            displayBigStringAt(currentCol*CELL_WIDTH + CELL_WIDTH_MIDDLE,
                               currentRow*CELL_HEIGHT + CELL_HEIGHT_MIDDLE, ">");
        }
        else if(direction == WEST){
            displayBigStringAt(currentCol*CELL_WIDTH + CELL_WIDTH_MIDDLE,
                               currentRow*CELL_HEIGHT + CELL_HEIGHT_MIDDLE, "<");
        }
        else if(direction == SOUTH){
            displayBigStringAt(currentCol*CELL_WIDTH + CELL_WIDTH_MIDDLE,
                               currentRow*CELL_HEIGHT + CELL_HEIGHT_MIDDLE, "v");
        }
    }





    task main(){

        for (int c = 0; c < MAZE_WIDTH; c++){
            for (int r = 0; r < MAZE_HEIGHT; r++){
                Maze[r][c].Visited = false;
                Maze[r][c].NWall = UNKNOWN;
                Maze[r][c].SWall = UNKNOWN;
                Maze[r][c].EWall = UNKNOWN;
                Maze[r][c].WWall = UNKNOWN;
            }
        }

        // Assigning walls [row][col]
        for (int c = 0; c < MAZE_WIDTH; c++){
            Maze[0][c].SWall = PRESENT;
            Maze[LAST_MAZE_HEIGHT_INDEX][c].NWall = PRESENT;
        }

        for (int r = 0; r < MAZE_HEIGHT; r++){
            Maze[r][0].WWall = PRESENT;
            Maze[r][LAST_MAZE_WIDTH_INDEX].EWall = PRESENT;
        }

        int direction = NORTH;

        Maze[currentRow][currentCol].entryDir = direction;
        Maze[currentRow][currentCol].Visited = true;

        while(currentRow != END_ROW || currentCol != END_COL){
            direction = MovementWithSensor(direction);
            entered[lastEnteredIdx] = direction;
            lastEnteredIdx++;
        }

        playTone(FREQUENCY, MILI_TO_BEEP_FOR);

        deleteDuplicates();

        sleep(MILI_TO_BEEP_FOR * 10);

        reverseDirection();
        
        direction = goingBackFastestRoute(direction);

        drawInfo(direction);

        sleep(390000);
    }



    void deleteDuplicates(){
        int idx = -1;

        while(idx < lastEnteredIdx){
            idx++;

            if(abs(entered[idx] - entered[idx + 1]) == 2){
                for(int moveOGTo = idx; moveOGTo <= lastEnteredIdx - 2; moveOGTo++){
                    entered[moveOGTo] = entered[moveOGTo + 2];
                }
                lastEnteredIdx = lastEnteredIdx - 2;
                idx = -1;
            }
        }
    }


    void reverseDirection(){
        for(int idx = 0; idx <= lastEnteredIdx; idx++){
            if(entered[idx]==EAST){
                entered[idx] = WEST;
            }
            else if(entered[idx]==SOUTH){
                entered[idx] = NORTH;
            }
            else if(entered[idx]==WEST){
                entered[idx] = EAST;
            }
            else if(entered[idx]==NORTH){
                entered[idx] = SOUTH;
            }
        }
    }


    int goingBackFastestRoute(int direction){

        for(int idx = lastEnteredIdx - 1; idx >= 0; idx--){
            reAdjustWayBack(direction);
            int turnNum = entered[idx] - direction;

            if(abs(turnNum) == 2){
                direction = Turn90CW(direction);
                direction = Turn90CW(direction);
            }
            else if(turnNum == 3){
                direction = Turn90CCW(direction);
            }
            else if(turnNum == -3){
                direction = Turn90CW(direction);
            }
            else if(turnNum == 1){
                direction = Turn90CW(direction);
            }
            else if(turnNum == -1){
                direction = Turn90CCW(direction);
            }
            goFwdCell(direction);
        }
        return direction;
    }


    void goFwdCell(int direction){
        setMotorSyncEncoder(leftDrive, rightDrive, 0, 
                            (SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO 
                            * ONE_ROTATION, FORWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        if (direction == NORTH){
            Maze[currentRow][currentCol].NWall = false;
            currentRow++;
            Maze[currentRow][currentCol].SWall = false;
        }
        else if (direction == SOUTH){
            Maze[currentRow][currentCol].SWall = false;
            currentRow--;
            Maze[currentRow][currentCol].NWall = false;
        }
        else if (direction == EAST){
            Maze[currentRow][currentCol].EWall = false;
            currentCol++;
            Maze[currentRow][currentCol].WWall = false;
        }
        else if (direction == WEST){
            Maze[currentRow][currentCol].WWall = false;
            currentCol--;
            Maze[currentRow][currentCol].EWall = false;
        }

        Maze[currentRow][currentCol].entryDir = direction;
        Maze[currentRow][currentCol].Visited = true;

        timesForwardWithoutReadjust++;
    }





    int Turn90CCW(int direction){
        setMotorSyncEncoder(leftDrive, rightDrive, -100, QUARTER_ROTATION * DRIVE_GEAR_RATIO, 
                            FORWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        direction = findLeft(direction);
        drawInfo(direction);
        return direction;
    }


    int Turn90CW(int direction){
        setMotorSyncEncoder(leftDrive, rightDrive, 100, QUARTER_ROTATION * DRIVE_GEAR_RATIO,
                            FORWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        direction = findRight(direction);
        drawInfo(direction);
        return direction;
    }


    int thereIsWall(){
        if(getUSDistance(distance)<=DIST_BETWEEN_BOT_AND_WALL || getUSDistance(distance)==255){
            return 1;
        }
        return 0;
    }


    void writeWall(int direction){
        if(direction == NORTH && thereIsWall()){
            Maze[currentRow][currentCol].NWall = PRESENT;
            if(currentRow + 1 <= LAST_MAZE_HEIGHT_INDEX){
                Maze[currentRow + 1][currentCol].SWall = PRESENT;
            }
        }
        else if(direction == SOUTH && thereIsWall()){
            Maze[currentRow][currentCol].SWall = PRESENT;
            if(currentRow - 1 >= 0){
                Maze[currentRow - 1][currentCol].NWall = PRESENT;
            }
        }
        else if(direction == EAST && thereIsWall()){
            Maze[currentRow][currentCol].EWall = PRESENT;
            if(currentCol + 1 <= LAST_MAZE_WIDTH_INDEX){
                Maze[currentRow][currentCol + 1].WWall = PRESENT;
            }
        }
        else if(direction == WEST && thereIsWall()){
            Maze[currentRow][currentCol].WWall = PRESENT;
            if(currentCol - 1 >= 0){
                Maze[currentRow][currentCol - 1].EWall = PRESENT;
            }
        }
        else if(direction == NORTH && !thereIsWall()){
            Maze[currentRow][currentCol].NWall = false;
            if(currentRow + 1 <= LAST_MAZE_HEIGHT_INDEX){
                Maze[currentRow + 1][currentCol].SWall = false;
            }
        }
        else if(direction == SOUTH && !thereIsWall()){
            Maze[currentRow][currentCol].SWall = false;
            if(currentRow - 1 >= 0){
                Maze[currentRow - 1][currentCol].NWall = false;
            }
        }
        else if(direction == EAST && !thereIsWall()){
            Maze[currentRow][currentCol].EWall = false;
            if(currentCol + 1 <= LAST_MAZE_WIDTH_INDEX){
                Maze[currentRow][currentCol + 1].WWall = false;
            }
        }
        else if(direction == WEST && !thereIsWall()){
            Maze[currentRow][currentCol].WWall = false;
            if(currentCol - 1 >= 0){
                Maze[currentRow][currentCol - 1].EWall = false;
            }
        }	
    }


    // Checking order, North(0), East(1), West(3) then South(2)
    // right, north, left, back
    int MovementWithSensor(int direction){

        int enteringDirectionWall = thereIsWall();
        writeWall(direction);
        reAdjustWayBack(direction);
        
        // turn to check if wall is right
        if(isThereWallInDir(findRight(direction)) == UNKNOWN 
           || isThereWallInDir(findRight(direction)) == NOT_PRESENT){
            direction = Turn90CW(direction);
            writeWall(direction);
            
            // go right if no wall right
            if(!thereIsWall()){
                goFwdCell(direction);
                return direction;
            }
            else{
                direction = Turn90CCW(direction);
                reAdjustWayBack(direction);
            }
        }		
        if(!enteringDirectionWall){
                goFwdCell(direction);
                return direction;
        }
        
        // At this point, we know there r walls on the R and N
        // We are facing N 
        // if we know there is wall left, go thru back
        if(isThereWallInDir(findLeft(direction)) == UNKNOWN 
           || isThereWallInDir(findLeft(direction)) == NOT_PRESENT){
           
            direction = Turn90CCW(direction);
            writeWall(direction);
                            
            if(!thereIsWall()){
                goFwdCell(direction);
                return direction;
            }
            else{
                reAdjustWayBack(direction);
                direction = Turn90CCW(direction);
                goFwdCell(direction);
                return direction;
            }	
        }
        else{
            reAdjustWayBack(direction);
            direction = Turn90CCW(direction);
            direction = Turn90CCW(direction);
            goFwdCell(direction);
            return direction;
        }
        sleep(1000000);
    }









    void reAdjustCCW(int direction){

        direction = Turn90CCW(direction);
        motor[rightDrive] = FORWARD;
        motor[leftDrive] = FORWARD;
        sleep(MILLISECS_TO_DRIVE_INTO_WALL);

        setMotorSyncEncoder(leftDrive, rightDrive, 0, ((SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)
                            *DRIVE_GEAR_RATIO * ONE_ROTATION)/7 + UNCERTAINTY_READJUST,
                             BACKWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        Turn90CW(direction);
        motor[rightDrive] = FORWARD;
        motor[leftDrive] = FORWARD;
        sleep(MILLISECS_TO_DRIVE_INTO_WALL);

        setMotorSyncEncoder(leftDrive, rightDrive, 0, 
                            ((SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO 
                            * ONE_ROTATION)/7 + UNCERTAINTY_READJUST, BACKWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        timesForwardWithoutReadjust = 0;
    }


    void reAdjustCW(int direction){

        direction = Turn90CW(direction);
        motor[rightDrive] = FORWARD;
        motor[leftDrive] = FORWARD;
        sleep(MILLISECS_TO_DRIVE_INTO_WALL);

        setMotorSyncEncoder(leftDrive, rightDrive, 0,
                            ((SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO 
                            * ONE_ROTATION)/7 + UNCERTAINTY_READJUST, BACKWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        Turn90CCW(direction);
        motor[rightDrive] = FORWARD;
        motor[leftDrive] = FORWARD;
        sleep(MILLISECS_TO_DRIVE_INTO_WALL);

        setMotorSyncEncoder(leftDrive, rightDrive, 0,
                            ((SIZE_OF_ONE_CELL / CIRCUMFERENCE_OF_WHEEL)*DRIVE_GEAR_RATIO 
                            * ONE_ROTATION)/7 + UNCERTAINTY_READJUST, BACKWARD);

        repeatUntil(!getMotorRunning(leftDrive) && !getMotorRunning(rightDrive)){

        }
        timesForwardWithoutReadjust = 0;
    }


    void reAdjustWayBack(int direction){
        int enteringWall = thereIsWall();

        if(timesForwardWithoutReadjust >=  CELLS_TO_READJUST_AFTER){
            if(isThereWallInDir(findLeft(direction)) == PRESENT && enteringWall){
                reAdjustCCW(direction);
            }
            else if(isThereWallInDir(findLeft(direction)) == PRESENT && 
                    isThereWallInDir(findBackDir(direction)) == PRESENT){
                direction = Turn90CCW(direction);
                reAdjustCCW(direction);
                direction = Turn90CW(direction);
            }
            else if(enteringWall && isThereWallInDir(findRight(direction)) == PRESENT){
                reAdjustCW(direction);
            }
            else if(isThereWallInDir(findRight(direction)) == PRESENT && 
           	        isThereWallInDir(findBackDir(direction)) == PRESENT){
                direction = Turn90CW(direction);
                reAdjustCW(direction);
                direction = Turn90CCW(direction);
            }
        }
    }


    int findBackDir (int currentDirection){
        if(currentDirection == NORTH){
            return SOUTH;
        }
        else if(currentDirection == EAST){
            return WEST;
        }
        else if(currentDirection == WEST){
            return EAST;
        }
        return NORTH;
    }




    int findRight(int currentDirection){

        if(currentDirection == WEST){
            return NORTH;
        }
        else{
            return currentDirection + 1;
        }
    }


    int findLeft(int currentDirection){

        if(currentDirection == NORTH){
            return WEST;
        }
        else{
            return currentDirection - 1;
        }
    }


    int isThereWallInDir(int wallDir){
        if(wallDir == NORTH && Maze[currentRow][currentCol].NWall == PRESENT){
            return PRESENT;
        }
        else if(wallDir == SOUTH && Maze[currentRow][currentCol].SWall == PRESENT){
            return PRESENT;
        }
        else if(wallDir == EAST && Maze[currentRow][currentCol].EWall == PRESENT){
            return PRESENT;
        }
        else	if(wallDir == WEST && Maze[currentRow][currentCol].WWall == PRESENT){
            return PRESENT;
        }
        
        if(wallDir == NORTH && Maze[currentRow][currentCol].NWall == UNKNOWN){
            return UNKNOWN;
        }
        else if(wallDir == SOUTH && Maze[currentRow][currentCol].SWall == UNKNOWN){
            return UNKNOWN;
        }
        else if(wallDir == EAST && Maze[currentRow][currentCol].EWall == UNKNOWN){
            return UNKNOWN;
        }
        else	if(wallDir == WEST && Maze[currentRow][currentCol].WWall == UNKNOWN){
            return UNKNOWN;
        }
        return NOT_PRESENT;
    }
\end{verbatim}
\end{linenumbers}
\end{document}
