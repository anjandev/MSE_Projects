#pragma config(Sensor, S4,     light,          sensorEV3_Color)
#pragma config(Motor,  motorA,          innerMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          outerMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float atan2d(float y, float x);
float sqd(float num2Square);

float const L1 = 9; // everything in cm
float const L2 = 13.5;

float const INNER_GEAR_RATIO_MULTIPLE = 40;
float const OUTER_GEAR_RATIO_MULTIPLE = 5;

int const SAMPLING_TIME = 5;

int const FORWARD = 55;

void moveToCoords1 (float x, float y){

	float YForTheta2_Nosqd = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float YForTheta2 = sqrt(1-sqd(YForTheta2_Nosqd));
	float XForTheta2 = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	float theta2 = atan2d(YForTheta2, XForTheta2);

	int speed = FORWARD;

	if (x <= 0){
		speed = FORWARD + 11;
	}
	else{
		speed = FORWARD;
	}

  float k1 = L2 * cosDegrees(theta2) + L1;
  float k2 = L2 * sinDegrees(theta2);
  float theta1 = atan2d(y,x) - atan2d(k2, k1);

  setMotorTarget(innerMotor, theta1 * INNER_GEAR_RATIO_MULTIPLE, speed);
  setMotorTarget(outerMotor, theta2 * OUTER_GEAR_RATIO_MULTIPLE, speed / OUTER_GEAR_RATIO_MULTIPLE);

}


task main()
{
	sleep(3000);

	if (!datalogOpen(2, 2, false)){
		displayCenteredTextLine(4,"Unable to open datalog");
	}

	// move arm into intial position
	float const INITIAL_X = 15;
	float const INITIAL_Y = 14;

	moveToCoords1(INITIAL_X, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}

	float const X_DECREMENT = 1;

	sleep(3000);


	int index = 0;
	clearTimer(T1);

	for(float x = INITIAL_X; x > -INITIAL_X; x-=X_DECREMENT){
		moveToCoords1(x, INITIAL_Y);
		repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
			if(time1[T1] > SAMPLING_TIME){
				datalogAddLong(0,(long) index+1000);
				datalogAddLong(0,(long) SensorValue[light]);
				clearTimer(T1);
				index++;
			}
		}
	}

	datalogClose();

	moveToCoords1(L1+L2, 0);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
	}


}

float sqd(float num2Square){
	return num2Square *	num2Square;
}

float atan2d(float y, float x){
	return radiansToDegrees(atan2(y, x));
}
