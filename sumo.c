#pragma config(Sensor, S1,     eyes,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     light,          sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          rightDrive,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          leftDrive,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// TODO REMEMBER TO ADD TOUCH
#define WHITE_THRESH	70
#define ROTATION 360
#define BACKWARDS 100
// Forwards means towards where eyes are seeing
#define FORWARDS -100
#define WHITE -1
#define BLACK 1
int const DEG_BACK_LINE = 800;
int const HALF_ROT_FRAC = 23;
#define SEC_TO_MILLI 1000
#define SEC_TOGO_STRAIGHT 3
// constants to define whether the back of the bot is on the stage or off
#define BACKOFF 0
#define BACKON 1

int const FRAC_TO_ROT_90 = 23;
int const SEC_TO_TRY_GOING_FROM_LINE = 2;
int const DIST_TO_CHARGE_CM = 5;


void rotateLeftOutside(float fraction){
	// inside pivot is right
	moveMotorTarget(rightDrive, ROTATION * fraction, BACKWARDS);
	moveMotorTarget(leftDrive, ROTATION * fraction, FORWARDS);
    while(checkWhite() != WHITE && !backOff() && getMotorSpeed(leftDrive) > 0){

    }
}

void rotateRightOutside(float fraction){
	// inside pivot is left
	moveMotorTarget(rightDrive, ROTATION * fraction, FORWARDS);
	moveMotorTarget(leftDrive, ROTATION * fraction, BACKWARDS);
    while(checkWhite() != WHITE && !backOff() && getMotorSpeed(rightDrive) > 0){

    }
}

int backOff(){
    if(SensorValue[touch] == BACKOFF){
        return 1;
    }
    else if(SensorValue[touch] == BACKON){
        return 0;
    }
}


int checkWhite(){
	if(SensorValue[light] > WHITE_THRESH){
		return -1;
	}
	else{
		// 1 means light is detecting black
		return 1;
	}
}

void beginningTurn(){
	moveMotorTarget(leftDrive, DEG_BACK_LINE, BACKWARDS);
	moveMotorTarget(rightDrive, DEG_BACK_LINE, BACKWARDS);
	waitUntilMotorStop(leftDrive);

	rotateLeftOutside(HALF_ROT_FRAC);
}

//left go forward
// right go back

void getOffWhite(){
    if(checkWhite() == WHITE){
        clearTimer(T1);
        motor[leftDrive] = BACKWARDS;
        motor[rightDrive] = BACKWARDS;
        delay(SEC_TO_TRY_GOING_FROM_LINE * SEC_TO_MILLI);
        rotateRightOutside(FRAC_TO_ROT_90);
    }
}

void getBackOn(){
    if(backOff()){
        clearTimer(T1);
        motor[leftDrive] = FORWARDS;
        motor[rightDrive] = FORWARDS;
        delay(SEC_TO_TRY_GOING_FROM_LINE * SEC_TO_MILLI);
        rotateLeftOutside(FRAC_TO_ROT_90);
    }
}

void charge(){

    while(botInFront() && checkWhite() != WHITE && !backOff()){
        motor[leftDrive] = 100;
        motor[rightDrive] = 100;
    }
}

int botInFront(){
    if(SensorValue[eyes] <= DIST_TO_CHARGE_CM){
        return 1;
    }
    else{
        return 0;
    }
}

task main()
{
	int firstTurn = 1;

	while(firstTurn){
		motor[leftDrive] = FORWARDS;
		motor[rightDrive] = FORWARDS;

		if(checkWhite() == WHITE){
			displayTextLine(4, "FIRST TURN");
			beginningTurn();
			firstTurn = 0;
		}	
	}

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
	clearTimer(T1);

	while(1){
        motor[leftDrive] = 100;
        motor[rightDrive] = 100;

        getOffWhite();
        getBackOn();

        charge();

        getOffWhite();
        getBackOn();

        int TIME_TIL_ROT_CHECK = 5;
        
        if(time1[T1] > TIME_TIL_ROT_CHECK * SEC_TO_MILLI){
            clearTimer(T1);

            int const TIME_TO_ROT_FOR = 3;

            while(!botInFront() && checkWhite() != WHITE && !backoff() && time1[T1] < TIME_TO_ROT_FOR * SEC_TO_MILLI){
                motor[leftDrive] = -100;
                motor[rightDrive] = 100;
            }    
            clearTimer(T1);
        }

        charge();
	}

}
