#pragma config(Sensor, S1,     eyes,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     light,          sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          rightDrive,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          leftDrive,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define WHITE_THRESH	70
#define ROTATION 360
#define BACKWARDS 100
// Forwards means towards where eyes are seeing
#define FORWARDS -100
#define WHITE -1
#define BLACK 1
int const DEG_BACK_LINE = 800;
int const HALF_ROT_FRAC = 23;
#define SEC_TO_MILLI 1000
#define SEC_TOGO_STRAIGHT 3

void rotateLeftOutside(float fraction){
	// inside pivot is right
	moveMotorTarget(rightDrive, ROTATION * fraction, FORWARDS);
	moveMotorTarget(leftDrive, ROTATION * fraction, BACKWARDS);
	waitUntilMotorStop(leftDrive);
}

void rotateRightOutside(float fraction){
	// inside pivot is left
	moveMotorTarget(rightDrive, ROTATION * fraction, FORWARDS);
	moveMotorTarget(leftDrive, ROTATION * fraction, BACKWARDS);
	waitUntilMotorStop(rightDrive);
}

int checkWhite(){
	if(SensorValue[light] > WHITE_THRESH){
		return -1;
	}
	else{
		// 1 means light is detecting black
		return 1;
	}
}

void beginningTurn(){
	moveMotorTarget(leftDrive, DEG_BACK_LINE, BACKWARDS);
	moveMotorTarget(rightDrive, DEG_BACK_LINE, BACKWARDS);
	waitUntilMotorStop(leftDrive);

	rotateLeftOutside(HALF_ROT_FRAC);
}

void hitLine(int rightDirection, int leftDirection){
	int const SEC_TO_IN_OPP_DIR = 5;

		motor[leftDrive] = -leftDirection;
		motor[rightDrive] = -rightDirection;
		delay(SEC_TO_MILLI * SEC_TO_IN_OPP_DIR);
		rotateLeftOutside(HALF_ROT_FRAC);

}
//left go forward
// right go back

void scout(){

	motor[leftDrive] = FORWARDS;
	motor[rightDrive] = FORWARDS;
	int leftDirection = FORWARDS;
	int rightDirection = FORWARDS;
	int const TURN_SCOUT_DEGREE = 12 * ROTATION;

	if(checkWhite() == WHITE){
		hitLine(rightDirection, leftDirection);
		clearTimer(T1);
	}
	// Do 360 check every certain time
	else if(time1[T1] > SEC_TOGO_STRAIGHT * SEC_TO_MILLI){
		resetMotorEncoder(leftDrive);

		while(getMotorEncoder(leftDrive) < TURN_SCOUT_DEGREE){
			motor[leftDrive] = FORWARDS;
			leftDirection = FORWARDS;
			motor[rightDrive] = BACKWARDS;
			rightDirection = BACKWARDS;
			
			if(checkWhite() == WHITE){
				hitLine(rightDirection, leftDirection);
				clearTimer(T1);
				break;
			}
		}
		clearTimer(T1);
	}

}

task main()
{
	int firstTurn = 1;

	while(firstTurn){
		motor[leftDrive] = FORWARDS;
		motor[rightDrive] = FORWARDS;

		if(checkWhite() == WHITE){
			displayTextLine(4, "FIRST TURN");
			beginningTurn();
			firstTurn = 0;
		}	
	}

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
	clearTimer(T1);
	
	while(1){
		scout();
	}

}