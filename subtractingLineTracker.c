#pragma config(Sensor, S1,     light,          sensorEV3_Color)
#pragma config(Motor,  motorA,          innerMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          outerMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float const L1 = 6.5; // everything in cm
float const L2 = 13;


#define FORWARD 50

float sqd(float num2Square){
	return num2Square *	num2Square;
}

float atan2d(float y, float x){
	return radiansToDegrees(atan2(y, x));
}

float calcTheta2(float x, float y){

	float YForTheta2 = sqrt(1-sqd(((sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2))));
	float XForTheta2 = (sqd(x)+sqd(y)-sqd(L1)-sqd(L2))/(2*L1*L2);
	return atan2d(YForTheta2, XForTheta2);
	
}

float calcTheta1(float theta2, float x, float y){

  float k1 = L2 * cosDegrees(theta2) + L1;
  float k2 = L2 * sinDegrees(theta2);
  return atan2d(y,x) - atan2d(k2, k1);
	
}


void moveToCoords (float x, float y, float oldX, float oldY){
	float theta2Old = calcTheta2(oldX, oldY);	

	float theta2 = calcTheta2(x, y) - calcTheta2(oldX, oldY);
	float theta1 = calcTheta1(theta2, x, y) - calcTheta1(theta2Old, oldX, oldY);

  float const INNER_GEAR_RATIO_MULTIPLE = 40;
  float const OUTER_GEAR_RATIO_MULTIPLE = 5;
  
  setMotorTarget(innerMotor, theta1 * INNER_GEAR_RATIO_MULTIPLE, FORWARD);
  setMotorTarget(outerMotor, theta2 * OUTER_GEAR_RATIO_MULTIPLE, FORWARD);
	 
  
}

task main()
{

	// move arm into intial position
	float const INITIAL_MOVE_X = 10;
	float const INITIAL_MOVE_Y = 17.5;
	
	float const INITIAL_X = L2 + L1;
	float const INITIAL_Y = 0;
	
	int const SAMPLING_TIME = 30;
	
	moveToCoords (INITIAL_MOVE_X, INITIAL_MOVE_Y, INITIAL_X, INITIAL_Y);
	repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
		
	}
		
	float const X_DECREMENT = 0.00001;
	float const X_MIN = -INITIAL_MOVE_X;
	
	float oldX = INITIAL_MOVE_X;
	float const STAYING_Y = INITIAL_MOVE_Y;
	
	//int index = 0;
	
	for(float x = INITIAL_MOVE_X; x > X_MIN; x -= X_DECREMENT){
		moveToCoords (x, STAYING_Y, oldX, STAYING_Y);
		repeatUntil(getMotorMoving(innerMotor) == 0 && getMotorMoving(outerMotor) == 0){
			/*
			clearTimer(T1);
			
			if (!datalogOpen(2, 2, false)){
				displayCenteredTextLine(4,"Unable to open datalog");
			}
			
			datalogAddLong(0,(long) SensorValue[light]);
			datalogAddLong(0,(long) index+1000);
			
			index += 1;
			datalogClose();
			
			while(getMotorMoving(innerMotor) == 1 && getMotorMoving(outerMotor) == 1 && time1[T1] < SAMPLING_TIME){
				
			}
			*/
		}
		oldX = x;
		displayCenteredTextLine(5, "%d", x);
	}
	
  
}